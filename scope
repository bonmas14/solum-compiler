The scope of a project:

1. parsing of a language
2. code gen with LLVM
3. Linking with raylib
4. Making small game
   - or hydraulic erosion simulation


BASIC POINTERS ARE NOT ARRAYS BY DEFAUT!
But they can be accessed with []. But we also can override it!


arr : [s32] = default;

// transforms into

arr = create_array_type(sizeof(s32));



how to cast?

// implicit conversions of extending types?
// but explicit conversion after that

a : s32;
b : s64;
u : f32;

u = cast(f32) a + b; // like in jai



u = (f32)a + (f32)b; // random shit like in C/C++




LOCAL SCOPE:

1. Minimal language:

+ math
+ variables, arrays and pointers
~ blocks and scopes
- function defines/calls (internal)

2. Expanding functionality:

- strings
- structs
- enums
- dynamic arrays
- iterators
- contexts (Jai)
- varargs or function overloading, params and so on

3. Extra:

- prototype functions (internal callbacks)
- compile time
- metaprogramming
- clojures?
- operator overloading 
- type extension functions ("hello world".self_print())
- SIMD


// --- PARSER STUFF

trees in arrays. but that is all for storing 

VALUE
UNARY
BINARY
TERNARY
LIST
EOF

Align is 4 


    0   1     2
L|3|U|V|B|V|V|B|B|V|V|V|E|

    0     1       2

L:  u     b       b
    |    / \     / \
    v   v   v   b   v
               / \
              v   v 


1. first is left then right, recursive

// --------------------- behaviour 

1. automatic dereference by '.'

2. We can create preload file that will create standart functions that are used 
in program. Like current context or standart functions like memset. 

3. VarArgs are bad they do bad stuff like: where are start and where are they end? 
we can just use arrays


a : s32;
b : f32 = 1.0;
c : addition = { return a + b; };
d : struct = { a : s32; b : s32; c : u64; };

addition : (f32 a, f32 b) -> f32 = prototype;

e : enum(u64) = { INVALID = 0, VALID = 0x8000 };


use "system";




// -----------------





// -----------------

keywords:
    - external:  for functions and variables (from c or anything) for linking (no definition, but specifiers like __stdcall, __fastcall).
    - default:   for returning 0 of specified in return/assignment type.
    - override:  for overriding operators
    - prototype: explicitly specify that function declaration is a prototype (alias) of function pointer.
    - module:    to organize work
    - use:       for acessing modules
    - noinit:    so specify explicitly that user doesnt need to initialize this variable

    - export:    for exporting fuctions to a global export table (we will need to add different things like __stdcall __fastcall and so on)


// --------------------- no initialization


freq : float = noinit; // will skip memset to zero for this variable


test : struct = {
    hello : s32;
    world : string;
};

t : test = noinit; // t has garbage in it


// --------------------- pointers

freq : s32 = 440;

ptr  : ^s32  = ^freq;
ptr2 : ^^s32 = ^ptr;
ptr3 : ^s32  = @ptr2;

if (freq == @@ptr2) {
    print("valid");
}

// --------------------- generics

list : struct<value_type> = {
    count : u64;
    size  : u64;
    data  : ^value_type;
};

create_list : <value_type>(size : s32) -> value_type, bool {
    data : ^value_type = allocate<value_type>(size);

    if (data == null) {
        return default, false;
    }

    output : list<value_type> = default;

    output.size = size;
    output.data = data;

    return output, true;
};

value, valid : list<s32>, bool = create_list<s32>(10);
// or 
value, valid := create_list<s32>(10);

sum : <arr_type>(arr : ^arr_type, length : s64) -> arr_type = {
    result : arr_type = 0;

    for (i : s64 = 0; i < length; i++) {
        result += arr[i];         // ------------- this will raise a operator override error
                                  // for situation when override with this type doesnt exist
                                  // or it returns different type that needed here.
    }

    return result;
};

arr : [4]s32 = { 0, 1, 2, 3 }; // multiple dimensions arrays? no.

result := sum(arr, 4);
// or
result : s32 = sum<s32>(arr, 4);
// or 
result : s32;
result = sum(arr, 4);

// 
<any_type, struct struct_type, prototype function_type, simple from_u8_to_f64>

tuple : struct<A, B> = {
    A a;
    B b;
}

// only last can be variable
var_t : struct<V> = {
    V args;
}


a : var_t<s32[10]>; 

a.args[0] = 23;
a.args[1] = 1000;



// variable type count???


// --------------------- anonymous struct/union members

some : struct<T> = { // this is type definition. this is why it cant be anon
      test : u32;

      named_union : union = { // this is member definition
          test : s32;
          struct = { // anon member definition
              same_test : s32;
          };

          buffer : u8[T];
      };
 }





// --------------------- function pointers

result := { print("hello!"); };

callback : (a : s32, b : s32) -> s32, bool = prototype; 
void_callback : () = prototype;


my_callback : callback = {
    result : s32 = a + b;
    return result, true;
};

get_callback : () -> callback = {
    return my_callback;
};

res, valid : s32, bool = get_callback().(4, 2);        // <<<<<<< 

// ------------- external functions

InitWindow : () = external(__fastcall);

InitWindow();


callback : () = prototype;

my : callback = {
};



// ------------- operator overrides

override + : (a : vec2, b : vec2) -> vec2 = {
    sum : vec2;

    sum.x = a.x + b.x;
    sum.y = a.y + b.y;

    return sum;
}

val : s32 = 5;
s32 bit0 = val[0]; // gets first bit of s32

// overrides array get expression for signed integer
override [] : (on_type : s32, u64 index) -> s32 {
    if index > 32 {
        print("too much for an int");
        return 0;
    }
    
    if on_type & (1 << index) {
        return 1;
    } 
    
    return 0;
}

override [,] : (type : ^s32, index1 : u32, index2 : u32) {
    // 2d arrays?
    // we can actually pass additional parameter and it wouldnt be index! 
    // so maybe you pass size of pointer as a first parameter?
}

overrride [] : (type : Dictionary<string, T>, key : string) -> pair<string, T> {
    
}

// some wild stuff!
override [,] : (type : List, command : string, index : u64) {
    if (command == "delete") {
        type.delete_element_at(index);
    }
    else if (command == "add") {

    }
}


// -------------

list : struct<T> = {
    count : u64;
    size  : u64;
    data  : ^T;
}


create : <T>(prealloc : u64) -> list<T>, bool = {
    if (prealloc == 0) {
        return default, false;
    }

    data : ^ T = allocate<T>(prealloc);

    if (data == null) {
        return default, false;
    }

    output : list<T> = default; 

    output.size = size;
    output.data = data;

    return output, true;
}

add : <T>(context : list<T>, value : T) -> bool = {
}

// start of file main.slm

// should be in global scope for program to access them by name

main : (argc : s32, argv : ^^i8) -> s32 = {
    list = create<s32>(10);
    add(list, 3);
}


// ------- enum

tokens : enum<s32> = {
    EOF   = 0, 

    Identifier = 256,
    Constant   = 257,

    Error = 2048,
}

token := tokens.EOF;
token : tokens = tokens.Error;

// ------- loops

for 0..10 {
    print("%\n", it);
}

