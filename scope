The scope of a project:

1. parsing of a language
2. code gen with LLVM
3. Linking with raylib
4. Making small game
   - or hydraulic erosion simulation


But they can be accessed with []. But we also can override it!


arr : [s32] = default;

// transforms into

arr = create_array_type(sizeof(s32));

// one liners

func : (x : f32) -> f32 = sin(x);


how to cast?

// implicit conversions of extending types?
// but explicit conversion after that

a : s32;
b : s64;
u : f32;

u = cast(f32) a + b; // like in jai



u = (f32)a + (f32)b; // random shit like in C/C++




LOCAL SCOPE:

1. Minimal language:

+ math
+ variables, arrays and pointers
+ blocks and scopes
+ function defines/calls (internal)

- generating assembly

2. Expanding functionality:

- strings
- structs
- enums
- dynamic arrays
- iterators
- contexts (Jai)
- varargs or function overloading, params and so on

3. Extra:

- prototype functions (internal callbacks)
- compile time
- metaprogramming
- clojures?
- operator overloading 
- type extension functions ("hello world".self_print())
- SIMD

// --------------------- behaviour 

1. automatic dereference by '.'

2. We can create preload file that will create standart functions that are used 
in program. Like current context or standart functions like memset. 

3. VarArgs are bad they do bad stuff like: where are start and where are they end? 
we can just use arrays


a : s32;
b : f32 = 1.0;
c : addition = { return a + b; };
d : struct = { a : s32; b : s32; c : u64; };

addition : (f32 a, f32 b) -> f32 = prototype;

e : enum(u64) = { INVALID = 0, VALID = 0x8000 };

use "system";

// -----------------

keywords:
    - external:  for functions and variables (from c or anything) for linking .
    - default:   for returning 0 of specified in return/assignment type.
    - override:  for overriding operators
    - prototype: explicitly specify that function declaration is a prototype (alias) of function pointer.
    - module:    to organize work
    - use:       for acessing modules
    - noinit:    so specify explicitly that user doesnt need to initialize this variable
    - export:    for exporting fuctions to a global export table


// --------------------- pointers

freq : s32 = 440;

ptr  : ^s32  = ^freq;
ptr2 : ^^s32 = ^ptr;
ptr3 : ^s32  = @ptr2;

if (freq == @@ptr2) {
    print("valid");
}

// --------------------- anonymous struct/union members

some : struct<T> = { // this is type definition. this is why it cant be anon
      test : u32;

      named_union : union = { // this is member definition
          test : s32;
          _ : struct = { // anon member definition
              same_test : s32;
          };

          buffer : u8[T];
      };
 }





// --------------------- function pointers

result : () = { print("hello!"); };

callback : (a : s32, b : s32) -> s32, bool = prototype; 
void_callback : () = prototype;


my_callback : callback = {
    result : s32 = a + b;
    return result, true;
};

get_callback : () -> callback = {
    return my_callback;
};

res, valid : s32, bool = get_callback().(4, 2);        // <<<<<<< 

// ------------- external functions

InitWindow : () = external;

InitWindow();

callback : () = prototype;

my : callback = {
    
};



// ------------- operator overrides

override + : (a : vec2, b : vec2) -> vec2 = {
    sum : vec2;

    sum.x = a.x + b.x;
    sum.y = a.y + b.y;

    return sum;
}

val : s32 = 5;
s32 bit0 = val[0]; // gets first bit of s32

// overrides array get expression for signed integer
override [] : (on_type : s32, u64 index) -> s32 {
    if index > 32 {
        print("too much for an int");
        return 0;
    }
    
    if on_type & (1 << index) {
        return 1;
    } 
    
    return 0;
}

override [,] : (type : ^s32, index1 : u32, index2 : u32) {
    // 2d arrays?
    // we can actually pass additional parameter and it wouldnt be index! 
    // so maybe you pass size of pointer as a first parameter?
}

overrride [] : (type : Dictionary<string, T>, key : string) -> pair<string, T> {
    
}

// some wild stuff!
override [,] : (type : List, command : string, index : u64) {
    if (command == "delete") {
        type.delete_element_at(index);
    }
    else if (command == "add") {

    }
}

// ------- enum

tokens : enum s32 = {
    EOF   = 0, 

    Identifier = 256,
    Constant   = 257,

    Error = 2048,
}

token := tokens.EOF;
token : tokens = .Error;

// ------- loops

for 0..10 {
    print("%\n", it);
}

