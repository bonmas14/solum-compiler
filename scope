The scope of a project:

1. parsing of a language
2. code gen with LLVM
3. Linking with raylib
4. Making small game
   - or hydraulic erosion simulation



// --------------------- behaviour 

1. automatic dereference by '.'
Variables are immutabe by default.
thus they are referenced instead of copyed.
But return works only as copy, there is no return by reference.


This is relationships of states:

Vert: from
Hor:  to

          | Mutable | Immutable
Mutable   | ok      | ok
Immutable | error   | ok

Vert: from
Hor:  to
                       | Mut ptr x Mut data | Immut ptr x Mut data | Mut ptr x Immut data | Immut ptr x Immut data |
Mut   ptr x Mut data   | ok                 | ok                   | error (pointer alias)| error (pointer alias)  |
Immut ptr x Mut data   | error              | ok                   | error                | error (pointer alias)  |
Mut   ptr x Immut data | error              | error                | ok                   | ok                     |
Immut ptr x Immut data | error              | error                | error                | ok                     |


row 1,2 col 3,4 are warnings but not really. because it can be like that :


Ownership.



Local functions.



// -----------------

keywords:
    - external:  for functions and variables (from c or anything) for linking (no definition).
    - default:   for returning 0 of specified in return/assignment type.
    - override:  for overriding operators
    - prototype: explicitly specify that function declaration is a prototype (alias) of function pointer.
    - module:    to organize work
    - use:       for acessing modules
    - mut:       to make variable mutable


///

addr, valid : ^mut s32, bool = allocate<s32>(100);
if (valid) {
    work(addr, 100); // here it is not an warning to cast to a immutable data
    free(addr);
}

// it makes addr immutable pointer to an immutable addr
work : (addr : ^s32, count : s32) = {

}


///


2. 

// --------------------- pointers

freq : s32 = 440;

ptr  : ^s32  = ^freq;
ptr2 : ^^s32 = ^ptr;
ptr3 : ^s32  = @ptr2;

if (freq == @@ptr2) {
    print("valid");
}

// --------------------- references

freq : s32;
test : mut s32 = 10;

modulate(freq); // passed by reference by default
square(freq);   // passed by reference but wont compile because freq is not mutable
squre(test);    // passed by reference and mutated

modulate : (freq : s32) = { }

square : (val : mut s32) = { val *= val; }

tuple : struct = {
    a : s32;
    b : s32;
}

n : tuple;
m : mut tuple;
x : mut tuple;

n.a = 1; // error because it is not mutable;
m.a = 1; // no error

ptr_n : ^tuple     = ^n; 
ptr_e : ^mut tuple = ^n;  // error. cause tuple is immutable
ptr_m : ^mut tuple = ^m; 

ptr_x : mut ^mut tuple      = ^x;  // mutable pointer to a mutable tuple
ptr_f : mut ^mut ^mut tuple = ^^x; // mutable pointer to a mutable pointer that points to a mutalbe tuple
ptr_z : mut ^tuple          = ^n;  // mutable pointer to an immutable tuple

ptr_n.a = 1; // error. because ptr_n is not mutable pointer with not mutalbe data

ptr_m.a = 1; // no error
ptr_m   = x; // error because pointer is not mutable
ptr_x   = m; // no error because pointer is mutable

create_tuple : (l : s32, r : s32) -> tuple = {
    res : mut tuple;

    res.a = l;
    res.b = r;

    return res;
}

t := create_tuple(22, 32);

// ----------------- pointer aliasing

pointer aliasing can only happen in situaltions:

1. 
do_stuff : (a : ^mut s32, b : ^mut s32) = {
    // a can be equal to b.
    // or changes in a can lead to changes in b
}

this is because we can promise to a compiler that we wont modify data of pointer.


but it wont work when we do stuff like raw pointers that equal to int values:
example:

a : []s32 = {1, 2};

b : ^s32     = a + 1; // valid. wont change anything 

c : ^mut s32 = a + 1; // wrong and wont compile, because we cant promise
                      // to pointer 'a' that it's data will remain constant

points_to : mut s32 = a;   // this will drop the promise of 'a' pointer that its data is constant, 
                           // because dont look at it as a pointer.
                           // 
                           // we can do warning here, error, OR be silent until this variable is used
                           // as in next line. 
                           // we can scan all places where this variable is used step into functions and try to find
                           // potential transformation into mutable pointer. 

d : ^mut s32 = points_to;  // this will be normal line of code. but it actually 
                           // breaks the promise of pointer 'a' that it's data is constant.

// --------------------- generics

list : struct<value_type> = {
    count : u64;
    size  : u64;
    data  : ^value_type;
};

create_list : <value_type>(size : s32) -> value_type, bool {
    data : ^value_type = allocate<value_type>(size);

    if (data == null) {
        return default, false;
    }

    output : list<value_type> = default;

    output.size = size;
    output.data = data;

    return output, true;
};

value, valid : list<s32>, bool = create_list<s32>(10);
// or 
value, valid := create_list<s32>(10);

sum : <arr_type>(arr : ^arr_type, length : s64) -> arr_type = {
    result : arr_type = 0;

    for (i : s64 = 0; i < length; i++) {
        result += arr[i];         // ------------- this will raise a operator override error
                                  // for situation when override with this type doesnt exist
                                  // or it returns different type that needed here.
    }

    return result;
};

arr : [4]s32 = { 0, 1, 2, 3 }; // multiple dimensions arrays? no.

result := sum(arr, 4);
// or
result : s32 = sum<s32>(arr, 4);
// or 
result : s32;
result = sum(arr, 4);

// --------------------- function pointers

result := { print("hello!"); };

callback : (a : s32, b : s32) -> s32, bool = prototype; 
void_callback : () = prototype;


my_callback : callback = {
    result : s32 = a + b;
    return result, true;
};

get_callback : () -> callback = {
    return my_callback;
};

res, valid : s32, bool = get_callback().(4, 2);        // <<<<<<< 

// ------------- external functions

InitWindow := external;

InitWindow();

// ------------- operator overrides

override + : (a : vec2, b : vec2) -> vec2 {
    sum : vec2;

    sum.x = a.x + b.x;
    sum.y = a.y + b.y;

    return sum;
}

// -------------

list : struct<T> = {
    count : u64;
    size  : u64;
    data  : ^mut T;
}


create : <T>(prealloc : u64) -> mut list<T>, bool = {
    if (prealloc == 0) {
        return default, false;
    }

    data : ^mut T = allocate<T>(prealloc);

    if (data == null) {
        return default, false;
    }

    output : mut list<T> = default; 

    output.size = size;
    output.data = data;

    return output, true;
}

add : <T>(context : mut list<T>, value : T) -> bool = {
}

// start of file main.slm

// should be in global scope for program to access them by name

main : (argc : s32, argv : ^^i8) -> s32 = {
    list = create<s32>(10);
    add(list, 3);
}


// ------- enum

tokens : enum<s32> = {
    EOF   = 0, 

    Identifier = 256,
    Constant   = 257,

    Error = 2048,
}

token := tokens.EOF;
token : tokens = tokens.Error;
