The scope of a project:

1. parsing of a language
2. code gen with LLVM
3. Linking with raylib
4. Making small game
   - or hydraulic erosion simulation



// --------------------- behaviour 

1. automatic dereference by '.'
Variables are immutabe by default.
thus they are referenced instead of copyed.
But return works only as copy, there is no return by reference.


This is relationships of states:

Vert: from
Hor:  to

          | Mutable | Immutable
Mutable   | ok      | ok
Immutable | error   | ok

Vert: from
Hor:  to
                       | Mut ptr x Mut data | Immut ptr x Mut data | Mut ptr x Immut data | Immut ptr x Immut data |
Mut   ptr x Mut data   | ok                 | ok                   | warn                 | warn                   |
Immut ptr x Mut data   | error              | ok                   | error                | warn                   |
Mut   ptr x Immut data | error              | error                | ok                   | ok                     |
Immut ptr x Immut data | error              | error                | error                | ok                     |


row 1,2 col 3,4 are warnings but not really. because it can be like that :


Ownership.



Local functions.


///

addr, valid : ^mut s32, bool = allocate<s32>(100);
if (valid) {
    work(addr, 100); // here it is not an warning to cast to a immutable data
    free(addr);
}

// it makes addr immutable pointer to an immutable addr
work : (addr : ^s32, count : s32) = {

}


///


2. 

// --------------------- pointers

freq : s32 = 440;

ptr  : ^s32  = @freq;
ptr2 : ^^s32 = @ptr;
ptr3 : ^s32  = ^ptr2;

if (freq == @@ptr2) {
    print("valid");
}

// --------------------- references

freq : s32;
test : mut s32 = 10;

modulate(freq); // passed by reference by default
square(freq);   // passed by reference but wont compile because freq is not mutable
squre(test);    // passed by reference and mutated

modulate : (freq : s32) = { }

square : (val : mut s32) = { val *= val; }

tuple : struct = {
    a : s32;
    b : s32;
}

n : tuple;
m : mut tuple;
x : mut tuple;

n.a = 1; // error because it is not mutable;
m.a = 1; // no error

ptr_n : ^tuple     = @n; 
ptr_e : ^mut tuple = @n;  // error. cause tuple is immutable
ptr_m : ^mut tuple = @m; 

ptr_x : mut ^mut tuple      = @x;  // mutable pointer to a mutable tuple
ptr_f : mut ^mut ^mut tuple = @@x; // mutable pointer to a mutable pointer that points to a mutalbe tuple
ptr_z : mut ^tuple          = @n;  // mutable pointer to an immutable tuple

ptr_n.a = 1; // error. because ptr_n is not mutable pointer with not mutalbe data

ptr_m.a = 1; // no error
ptr_m   = x; // error because pointer is not mutable
ptr_x   = m; // no error because pointer is mutable

create_tuple : (l : s32, r : s32) -> tuple = {
    res : mut tuple;

    res.a = l;
    res.b = r;

    return res;
}

t := create_tuple(22, 32);

// -----------------

keywords:
    - external:  for functions and variables (from c or anything) for linking (no definition).
    - default:   for returning 0 of specified in return/assignment type.
    - override:  for overriding operators
    - prototype: explicitly specify that function declaration is a prototype (alias) of function pointer.
    - module:    to organize work
    - use:       for acessing modules
    - mut:       to make variable mutable

// --------------------- generics

list : struct<value_type> = {
    count : u64;
    size  : u64;
    data  : ^value_type;
};

create_list : <value_type>(size : s32) -> value_type, bool {
    data : ^value_type = allocate<value_type>(size);

    if (data == null) {
        return default, false;
    }

    output : list<value_type> = default;

    output.size = size;
    output.data = data;

    return output, true;
};

value, valid : list<s32>, bool = create_list<s32>(10);
// or 
value, valid := create_list<s32>(10);

sum : <arr_type>(arr : ^arr_type, length : s64) -> arr_type = {
    result : arr_type = 0;

    for (i : s64 = 0; i < length; i++) {
        result += arr[i];         // ------------- this will raise a operator override error
                                  // for situation when override with this type doesnt exist
                                  // or it returns different type that needed here.
    }

    return result;
};

arr : [4]s32 = { 0, 1, 2, 3 }; // multiple dimensions arrays? no.

result := sum(arr, 4);
// or
result : s32 = sum<s32>(arr, 4);
// or 
result : s32;
result = sum(arr, 4);

// --------------------- function pointers

result := { print("hello!"); };

callback : (a : s32, b : s32) -> s32, bool = prototype; 
void_callback : () = prototype;


my_callback : callback = {
    result : s32 = a + b;
    return result, true;
};

get_callback : () -> callback = {
    return my_callback;
};

res, valid : s32, bool = get_callback().(4, 2);        // <<<<<<< 

// ------------- external functions

InitWindow := external;

InitWindow();

// ------------- operator overrides

override + : (a : vec2, b : vec2) -> vec2 {
    sum : vec2;

    sum.x = a.x + b.x;
    sum.y = a.y + b.y;

    return sum;
}

// -------------

list : struct<T> = {
    count : u64;
    size  : u64;
    data  : ^mut T;
}


create : <T>(prealloc : u64) -> mut list<T>, bool = {
    if (prealloc == 0) {
        return default, false;
    }

    data : ^mut T = allocate<T>(prealloc);

    if (data == null) {
        return default, false;
    }

    output : mut list<T> = default; 

    output.size = size;
    output.data = data;

    return output, true;
}

add : <T>(context : mut list<T>, value : T) -> bool = {
}

// start of file main.slm

// should be in global scope for program to access them by name

main : (argc : s32, argv : ^^i8) -> s32 = {
    list = create<s32>(10);
    add(list, 3);
}


// ------- enum

tokens : enum<s32> = {
    EOF   = 0, 

    Identifier = 256,
    Constant   = 257,

    Error = 2048,
}

token := tokens.EOF;
token : tokens = tokens.Error;
